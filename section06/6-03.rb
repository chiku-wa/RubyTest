#encoding: utf-8
# ===
# === 6.3 Rubyにおける正規表現オブジェクト
def section_06_03
  # 正規表現オブジェクトは、以下のように「/」で区切る
  regex = /\d{3}-\d{4}/
  p regex.class #=> Regexp

  # --- =~演算子
  # =~ を使うと、対象の文字列が正規表現に一致したかどうかを判定する
  # 存在する場合は、文字列が存在する位置を返す
  p "123-4567" =~ regex #=> 0
  p "A123-4567" =~ regex #=> 1

  # 存在しない場合はnilが返る
  p "123-456" =~ regex #=> nil

  # 上記の応用で、if文で判定することもできる
  zip_code = "123-4567"
  res = "マッチ"
  if zip_code =~ regex
    puts "#{res}しました"
  else
    puts "#{res}しませんでした"
  end

  # 左辺と右辺を入れ替えても結果は同じ
  # ただし、名前付きキャプチャ(6.3.3で詳細を説明)の場合は動作に違いが出る
  p /\d{3}-\d{4}/ =~ "123-4567" #=> 0
  p /\d{3}-\d{4}/ =~ "123-456" #=> nil

  # --- !~演算子
  # !~を使うと、マッチ"しなかった"ときにtrueを、マッチしたらfalseを返す
  p /\d{3}-\d{4}/ !~ "123-4567" #=> false
  p /\d{3}-\d{4}/ !~ "123-456" #=> true
end

section_06_03

# ===
# === 6.3.1 Rubularで視覚的にマッチする文字列を確認する
# 以下のサイトで、正規表現を確認できる。
# Rubular: a Ruby regular expression editor
# https://rubular.com/

# 6.2ですでに学習済みのため、本項では省略する。

# ===
# === 6.3.2 正規表現のキャプチャを利用する
def section_06_03_02
  # 例えば、ある文字列から数字だけを抜き出したいとする。
  birthday = "1980年9月10日"

  # 以下の正規表現だと、「年月日」も含んだひとつづきの文字列が抽出されてしまう
  regex = /\d+年\d+月\d+日/
  puts birthday.scan(regex) #=> 1980年9月10日

  # ---「()」で囲うキャプチャ機能を使うと抜き出したい部分を指定できる。
  regex_capture = /(\d+)年(\d+)月(\d+)日/

  # [matchメソッド]
  # 一致する場合：キャプチャごとに、一致した文字列を1要素とした配列を返す
  # 一致しない場合：nilを返す
  m = regex_capture.match(birthday)
  p m[1] #=> 1980
  p m[2] #=> 9
  p m[3] #=> 10

  # mathメソッドはStringクラス、Regexpクラスの両方に定義されているため、入れ替えても使用できる
  m_rvs = birthday.match(regex_capture)
  p m_rvs[1] #=> 1980
  p m_rvs[2] #=> 9
  p m_rvs[3] #=> 10
end

section_06_03_02
