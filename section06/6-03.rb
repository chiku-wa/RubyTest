#encoding: utf-8
# ===
# === 6.3 Rubyにおける正規表現オブジェクト
def section_06_03
  # 正規表現オブジェクトは、以下のように「/」で区切る
  regex = /\d{3}-\d{4}/
  p regex.class #=> Regexp

  # --- =~演算子
  # =~ を使うと、対象の文字列が正規表現に一致したかどうかを判定する
  # 存在する場合は、文字列が存在する位置を返す
  p "123-4567" =~ regex #=> 0
  p "A123-4567" =~ regex #=> 1

  # 存在しない場合はnilが返る
  p "123-456" =~ regex #=> nil

  # 上記の応用で、if文で判定することもできる
  zip_code = "123-4567"
  res = "マッチ"
  if zip_code =~ regex
    puts "#{res}しました"
  else
    puts "#{res}しませんでした"
  end

  # 左辺と右辺を入れ替えても結果は同じ
  # ただし、名前付きキャプチャ(6.3.3で詳細を説明)の場合は動作に違いが出る
  p /\d{3}-\d{4}/ =~ "123-4567" #=> 0
  p /\d{3}-\d{4}/ =~ "123-456" #=> nil

  # --- !~演算子
  # !~を使うと、マッチ"しなかった"ときにtrueを、マッチしたらfalseを返す
  p /\d{3}-\d{4}/ !~ "123-4567" #=> false
  p /\d{3}-\d{4}/ !~ "123-456" #=> true
end

section_06_03

# ===
# === 6.3.1 Rubularで視覚的にマッチする文字列を確認する
# 以下のサイトで、正規表現を確認できる。
# Rubular: a Ruby regular expression editor
# https://rubular.com/

# 6.2ですでに学習済みのため、本項では省略する。

# ===
# === 6.3.2 正規表現のキャプチャを利用する
def section_06_03_02
  # 例えば、ある文字列から数字だけを抜き出したいとする。
  birthday = "1980年9月10日"

  # 以下の正規表現だと、「年月日」も含んだひとつづきの文字列が抽出されてしまう
  regex = /\d+年\d+月\d+日/
  puts birthday.scan(regex) #=> 1980年9月10日

  # ---「()」で囲うキャプチャ機能を使うと抜き出したい部分を指定できる。
  regex_capture = /(\d+)年(\d+)月(\d+)日/

  # [matchメソッド]
  # 一致する場合：キャプチャごとに、一致した文字列を1要素とした配列を返す
  # 一致しない場合：nilを返す
  m = regex_capture.match(birthday)
  # n番目の値を取り出せる(添字の開始はからなので注意！)
  p m[1] #=> 1980
  p m[2] #=> 9
  p m[3] #=> 10

  # matchメソッドはStringクラス、Regexpクラスの両方に定義されているため、入れ替えても使用できる
  m_rvs = birthday.match(regex_capture)
  p m_rvs[1] #=> 1980
  p m_rvs[2] #=> 9
  p m_rvs[3] #=> 10
end

section_06_03_02

# ===
# === 6.3.3 キャプチャの結果に名前を付ける
def section_06_03_03
  # キャプチャをそのまま使うと、何番目に存在するのかを意識しなければならない。
  # キャプチャに名前を付けることてわかりやすくすることが可能
  # 以下のメタ文字を使う。
  # ?<キャプチャ名>
  regex_birthday = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日[.]*/
  birthday_message = "1980年9月10日生まれの人！誕生日おめでとう！"
  m = birthday_message.match(regex_birthday)

  # 配列の要素名に、キャプチャ名を渡せば抜き出せる
  # シンボル
  p m[:year] #=> 1980
  p m[:month] #=> 9
  p m[:day] #=> 10

  # 添字には文字列も可能
  p m["year"] #=> 1980

  # キャプチャ名を用いないときと同じ指定方法も可能
  p m[2] #=> 1

  # 左辺に正規表現リテラル、右辺に検査対象の文字列を置いて「~=」を使うと、キャプチャ名がそのまま
  # 変数に割り当てられる
  birthday = "1990年4月30日"
  # 正規表現に一致した(nilでない)場合に、変数に格納された値を出力する
  if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/ =~ birthday
    puts "#{year}/#{month}/#{day}" #=> 1990/4/30
  end

  birthday2 = "1990年5月31日"
  # 左辺と右辺を逆転すると変数への代入が行われなくなる(正規表現のチェックは行われる)
  if birthday2 =~ /(?<year2>\d+)年(?<month2>\d+)月(?<day2>\d+)日/
    # puts "#{year2}/#{month2}/#{day2}" #=> 1990/4/30
    #=> undefined local variable or method `year2' for main:Object (NameError)
  end
end

section_06_03_03

# ===
# === 6.3.4 正規表現と組み合わせると便利なStringクラスのメソッド
def section_06_03_04

  # --- scanメソッド
  # 正規表現に一致した部分を、配列で返す
  p "123 4567 8910".scan(/\d{3}/) #=>["123", "456", "891"]

  # キャプチャを使うと、キャプチャ部分だけが配列の配列(2次元配列)として返ってくる
  p "1990年12月31日 2010年2月1日".scan(/(\d+)年(\d+)月(\d+)日/) #=> [["1990", "12", "31"], ["2010", "2", "1"]]

  # 「?:」でキャプチャ対象外とした場合(単なるグループ化、マッチした文字列全体を取得したい場合)も、同様に配列として取り出される
  p "1990年12月31日 2010年2月1日".scan(/(?:\d+)年(?:\d+)月(?:\d+)日/) #=> ["1990年12月31日", "2010年2月1日"]
  # [補足]以下と同じ意味になる
  p "1990年12月31日 2010年2月1日".scan(/\d+年\d+月\d+日/) #=> ["1990年12月31日", "2010年2月1日"]
end

section_06_03_04
