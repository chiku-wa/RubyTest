#encoding: utf-8
# ===
# === 6.3 Rubyにおける正規表現オブジェクト
def section_06_03
  # 正規表現オブジェクトは、以下のように「/」で区切る
  regex = /\d{3}-\d{4}/
  p regex.class #=> Regexp

  # --- =~演算子
  # =~ を使うと、対象の文字列が正規表現に一致したかどうかを判定する
  # 存在する場合は、文字列が存在する位置を返す
  p "123-4567" =~ regex #=> 0
  p "A123-4567" =~ regex #=> 1

  # 存在しない場合はnilが返る
  p "123-456" =~ regex #=> nil

  # 上記の応用で、if文で判定することもできる
  zip_code = "123-4567"
  res = "マッチ"
  if zip_code =~ regex
    puts "#{res}しました"
  else
    puts "#{res}しませんでした"
  end

  # 左辺と右辺を入れ替えても結果は同じ
  # ただし、名前付きキャプチャ(6.3.3で詳細を説明)の場合は動作に違いが出る
  p /\d{3}-\d{4}/ =~ "123-4567" #=> 0
  p /\d{3}-\d{4}/ =~ "123-456" #=> nil

  # --- !~演算子
  # !~を使うと、マッチ"しなかった"ときにtrueを、マッチしたらfalseを返す
  p /\d{3}-\d{4}/ !~ "123-4567" #=> false
  p /\d{3}-\d{4}/ !~ "123-456" #=> true
end

section_06_03

# ===
# === 6.3.1 Rubularで視覚的にマッチする文字列を確認する
# 以下のサイトで、正規表現を確認できる。
# Rubular: a Ruby regular expression editor
# https://rubular.com/

# 6.2ですでに学習済みのため、本項では省略する。

# ===
# === 6.3.2 正規表現のキャプチャを利用する
def section_06_03_02
  # 例えば、ある文字列から数字だけを抜き出したいとする。
  birthday = "1980年9月10日"

  # 以下の正規表現だと、「年月日」も含んだひとつづきの文字列が抽出されてしまう
  regex = /\d+年\d+月\d+日/
  puts birthday.scan(regex) #=> 1980年9月10日

  # ---「()」で囲うキャプチャ機能を使うと抜き出したい部分を指定できる。
  regex_capture = /(\d+)年(\d+)月(\d+)日/

  # [matchメソッド]
  # 一致する場合：キャプチャごとに、一致した文字列を1要素とした配列を返す
  # 一致しない場合：nilを返す
  m = regex_capture.match(birthday)
  # n番目の値を取り出せる(添字の開始はからなので注意！)
  p m[1] #=> 1980
  p m[2] #=> 9
  p m[3] #=> 10

  # matchメソッドはStringクラス、Regexpクラスの両方に定義されているため、入れ替えても使用できる
  m_rvs = birthday.match(regex_capture)
  p m_rvs[1] #=> 1980
  p m_rvs[2] #=> 9
  p m_rvs[3] #=> 10
end

section_06_03_02

# ===
# === 6.3.3 キャプチャの結果に名前を付ける
def section_06_03_03
  # キャプチャをそのまま使うと、何番目に存在するのかを意識しなければならない。
  # キャプチャに名前を付けることてわかりやすくすることが可能
  # 以下のメタ文字を使う。
  # ?<キャプチャ名>
  regex_birthday = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日[.]*/
  birthday_message = "1980年9月10日生まれの人！誕生日おめでとう！"
  m = birthday_message.match(regex_birthday)

  # 配列の要素名に、キャプチャ名を渡せば抜き出せる
  # シンボル
  p m[:year] #=> 1980
  p m[:month] #=> 9
  p m[:day] #=> 10

  # 添字には文字列も可能
  p m["year"] #=> 1980

  # キャプチャ名を用いないときと同じ指定方法も可能
  p m[2] #=> 1

  # 左辺に正規表現リテラル、右辺に検査対象の文字列を置いて「~=」を使うと、キャプチャ名がそのまま
  # 変数に割り当てられる
  birthday = "1990年4月30日"
  # 正規表現に一致した(nilでない)場合に、変数に格納された値を出力する
  if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/ =~ birthday
    puts "#{year}/#{month}/#{day}" #=> 1990/4/30
  end

  birthday2 = "1990年5月31日"
  # 左辺と右辺を逆転すると変数への代入が行われなくなる(正規表現のチェックは行われる)
  if birthday2 =~ /(?<year2>\d+)年(?<month2>\d+)月(?<day2>\d+)日/
    # puts "#{year2}/#{month2}/#{day2}" #=> 1990/4/30
    #=> undefined local variable or method `year2' for main:Object (NameError)
  end
end

section_06_03_03

# ===
# === 6.3.4 正規表現と組み合わせると便利なStringクラスのメソッド
def section_06_03_04
  # --- scanメソッド
  # 正規表現に一致した部分を、配列で返す
  p "123 4567 8910".scan(/\d{3}/) #=>["123", "456", "891"]

  # キャプチャを使うと、キャプチャ部分だけが配列の配列(2次元配列)として返ってくる
  p "1990年12月31日 2010年2月1日".scan(/(\d+)年(\d+)月(\d+)日/) #=> [["1990", "12", "31"], ["2010", "2", "1"]]

  # 「?:」でキャプチャ対象外とした場合(単なるグループ化、マッチした文字列全体を取得したい場合)も、同様に配列として取り出される
  p "1990年12月31日 2010年2月1日".scan(/(?:\d+)年(?:\d+)月(?:\d+)日/) #=> ["1990年12月31日", "2010年2月1日"]
  # [補足]以下と同じ意味になる
  p "1990年12月31日 2010年2月1日".scan(/\d+年\d+月\d+日/) #=> ["1990年12月31日", "2010年2月1日"]

  # --- [],slice,slice!
  # []
  # []に正規表現を渡すと、マッチした文字列を返す
  zip_code = "郵便番号は123-4567です"
  p zip_code[/\d{3}-\d{4}/] #=> 123-4567

  # 複数一致した場合は、最初にマッチした文字列を返す
  zip_code_double = "郵便番号は999-9999と888-8888です"
  p zip_code_double[/\d{3}-\d{4}/] #=> 999-9999

  # キャプチャを使うと、第二引数で、何番目に一致したもの取り出すか指定できる
  birthday = "1980年11月23日"
  p birthday[/(\d+)年(\d+)月(\d+)日/, 1] #=> 1980
  p birthday[/(\d+)年(\d+)月(\d+)日/, 2] #=> 11
  p birthday[/(\d+)年(\d+)月(\d+)日/, 3] #=> 23

  # 名前付きキャプチャなら、名前で取り出すこともできる
  p birthday[/(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/, :day] #=> 23

  # slice
  # []のエイリアスメソッド
  p zip_code_double.slice(/\d+{3}-\d{4}/) #=> 999-9999

  # slice!を使うと、正規表現に一致した文字を、対象の文字列から取り除く
  string = "住所は123-4567です。"
  string.slice!(/\d+{3}-\d+{4}/)
  p string #=> 住所はです。

  # --- split
  # 引数の文字を区切り文字として、対象の文字列を配列に分解して返す
  text = "apple,banana-melon"
  p text.split(",") #=> ["apple","banana-melon"]

  # 正規表現を使って分解することもできる
  # 「,」または「-」を区切り文字として認識する
  p text.split(/,|-/) #=>["apple","banana","melon"]

  # --- gsub,gsub!
  # 第一引数の値を、第二引数の文字に置換する(replace)
  fruits = "banana,apple-melon"
  p fruits.gsub(",", "*") #=> banana*apple-melon
  # 正規表現でも置換可能
  p fruits.gsub(/,|-/, "*") #=> banana*apple*melon

  # trメソッドでも同様で、こちらのほうが高速(rubocopでもこちらが推奨されている)。
  p fruits.tr(",", "*") #=> banana*apple-melon
  # ただし、trメソッドの場合は第一引数に正規表現を使用できない
  # p fruits.tr(/,|-/, "*") #=> no implicit conversion of Regexp into String (TypeError)

  # キャプチャを使用することで、柔軟な置換処理が可能
  # 「\n」でn番目のキャプチャを参照できる
  birthday = "誕生日は1977年7月17日です。"
  puts birthday.gsub(/(\d+)年(\d+)月(\d+)日/, '\1-\2-\3') #=> 誕生日は1977-7-17です。

  # 【注意！】第二引数を「"」で囲むと、キャプチャを正常に抜き出せなくなる！
  puts birthday.gsub(/(\d+)年(\d+)月(\d+)日/, "\1-\2-\3") #=> 誕生日は--です。
  # →ダブルクォーテーションの中で「\X」と記すと、Xそのものを指す事になる

  # 名前付きキャプチャを使うことも可能
  # キャプチャを参照する場合は「\k<キャプチャ名>」と記す
  puts birthday.gsub(/((?<year>\d+)年(?<month>\d+)月(?<day>\d+)日)/, '\k<year>-\k<month>-\k<day>') #=> 誕生日は1977-7-17です。

  # ハッシュを用いて、変換する文字を使い分けることも可能
  # ハッシュで以下の通り変換するルールを作成
  # * 「:」を「→」に変換
  # * 「,」を「、」に変換
  h = { ":" => "→", "," => "、" }
  puts "日本のあるき方:自転車,徒歩,電車".gsub(/,|:/, h) #=> 日本の歩き方→自転車、徒歩、電車

  # 第二引数を省略し、ブロックを用いることで、置き換える文字列を柔軟に指定することもできる
  # 「,」と「:」を検索し、「:」なら「→」に変換する、それ以外は「、」に変換する(三項演算子)
  puts "日本のあるき方:自転車,徒歩,電車".gsub(/,|:/) { |m| m == ":" ? "→" : "、" }

  # gsub!は、文字列そのものを破壊的に変更する
  string = "日本のあるき方:自転車,徒歩,電車"
  h = { ":" => "→", "," => "、" }
  string.gsub!(/:|,/, h)
  puts string #=> 日本の歩き方→自転車、徒歩、電車

  # Stringクラスには、正規表現を使えるメソッドが他にも用意されている
  # class String (Ruby 2.6.0)
  # https://docs.ruby-lang.org/ja/latest/class/String.html
end

section_06_03_04
